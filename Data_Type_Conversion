#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
//#include <iomanip>
using namespace std;

class Complex {
	double real;
	double image;
public:
	Complex(void);
	Complex(int r);
	Complex(double r, double i);
	friend Complex operator+(Complex c1, Complex c2);
	operator float();
	operator int();
	void print();
};

Complex::Complex(void)
{
	real = 0;
	image = 0;
}

Complex::Complex(int r)
{
	real = r;
	image = 0;
}

Complex::Complex(double r, double i)
{
	real = r;
	image = i;
}

Complex operator+(Complex c1, Complex c2)
{
	Complex temp;
	temp.real = c1.real + c2.real;
	temp.image = c1.image + c2.image;
	return temp;
}

void Complex::print()
{
	cout << real << '+' << image << 'i' << endl;
}

Complex::operator float()
{
	cout << "Type changed to float" << endl;
	return float(real);
}

Complex::operator int()
{
	cout << "Type change to int" << endl;
	return int(real);
}

int main()
{
	Complex com1(2.2, 2.2);
	cout << "com1 = ";	
	com1.print();

	cout << "20+com1 = ";
	com1 = Complex(20) + com1;//20会自动调用Complex(int r)将整数20转换成Complex类型，然后再调用重载加号，赋值
	com1.print();

	cout << float(com1) * 0.5 << endl;
	Complex com2(3.3, 3.3);
	cout << "com2 = ";
	com2.print();
	cout << int(com2) * 10 << endl;


	//class 源类类名
	//{
	//	//...
	//	operator 目的类型()
	//	{
	//		//...
	//		return 目的类型的数据;
	//	}
	//	//...
	//};

	//其中，源类类名为要转换的源类类型；目的类型为要转换成为的类型，它既可以是用户自定义的类型，也可以是系统的预定义类型。
	//	在使用类类型转换函数时，需要注意以下几个问题：
	//	1)类类型转换函数只能定义为一个类的成员函数，而不能定义成类的友元函数。
	//	2)类类型转换函数既没有参数，也不显式给出返回类型。
	//	3)类类型函数中必须有“return 目的类型的数据；”的语句，既必须返回目的类型数据作为函数的返回值。
}

